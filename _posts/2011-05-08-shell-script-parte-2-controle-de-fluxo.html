---
layout: post
title: Shell Script - Parte 2 - Controle de Fluxo
categories:
- Aulas
- Blog
- Shell Script
tags:
- Aulas
- Bash
- shell script
status: publish
type: post
published: true
meta:
  _edit_last: '1'
---
[ad#propaganda]<br />
<p style="text-align: left;">Esta é a segunda parte das aulas de <strong>shell script</strong>. <a href="http://evaldojunior.com.br/blog/?p=1022" title="Shell Script – Parte 1 – Introdução">A primeira parte pode ser lida aqui</a>. Essas aulas são focadas na sintaxe do <strong>Bash</strong>, então nem tudo pode funcionar da mesma maneira no sh, ksh...</p><br />
<p style="text-align: left;">E vamos ao que interessa, mais sobre <strong>shell script</strong>:</p><br />
<br />
<h2>Tomada de Decisões</h2><br />
Em toda linguagem de programação existe alguma estrutura para tomada de decisões. Essa estrutura em geral é feita através do comando "<strong>if</strong>". O comando "<strong>if</strong>" analisa de uma expressão é verdadeira e então executa um bloco de código, caso a expressão seja falsa pode ser executado, ou não, um outro bloco.<br />
<br />
Em geral as linguagens de programação oferecem maneiras de verificar se um valor é igual, menor ou maior que outro. As formas mais comuns são:<br />
<ul><br />
	<li><strong>==</strong> : Igual à</li><br />
	<li><strong>!=</strong> : Diferente de</li><br />
	<li><strong>&lt;</strong> : Menor que</li><br />
	<li><strong>&gt;</strong> : Maior que</li><br />
	<li><strong>&lt;=</strong> : Menor ou igual à</li><br />
	<li><strong>&gt;=</strong> : Maior ou igual à</li><br />
</ul><br />
Em shell script os mesmos testes são obtidos com:<br />
<ul><br />
	<li><strong>-eq</strong> : (equal) Igual à</li><br />
	<li><strong>-ne</strong> : (not equal) Diferente de</li><br />
	<li><strong>-lt</strong> : (less than) Menor que</li><br />
	<li><strong>-gt</strong> : (greater than) Maior que</li><br />
	<li><strong>-le</strong> : (less or egual) Menor ou igual à</li><br />
	<li><strong>-ge</strong> : (greater or equal) Maior ou igual à</li><br />
</ul><br />
O uso do "<strong>if</strong>" em shell script é assim:<br />
<br />
<code bash><br />
#!/bin/bash<br />
if [ 2 -eq 4 ]<br />
then<br />
    echo "Esse echo nunca acontecerá"<br />
fi<br />
</code><br />
<br />
Repare que é necessário manter <strong>espaços</strong> entre os colchetes e os números, ou variáveis. O bloco após a palavra "<strong>then</strong>" será executado se a expressão dentro do "<strong>if</strong>" for verdadeira. O bloco "<strong>if</strong>" termina com a palavra "<strong>fi</strong>" que é "<strong>if</strong>" ao contrário. Essa é uma maneira simples de identificar o final de um "<strong>if</strong>" quando o encontramos.<br />
<br />
As expressões acima são mais comuns para tratar números. Para fazer comparações com textos use:<br />
<ul><br />
	<li><strong>=</strong> : Igual à (isso mesmo apenas um sinal de igual)</li><br />
	<li><strong>!=</strong> : Diferente de</li><br />
	<li><strong>-n</strong> : String existe e não é vazia (apenas um operador)</li><br />
	<li><strong>-z </strong>: String existe e é vazia (apenas um operador)</li><br />
</ul><br />
Veja um exemplo com Strings:<br />
<br />
<code bash><br />
#!/bin/bash<br />
echo "Digite seu nome: "<br />
read nome<br />
if [ -z $nome ]<br />
then<br />
    echo "Você não digitou seu nome!"<br />
else<br />
    echo "Olá, $nome"<br />
fi<br />
</code><br />
<br />
No script acima o "<strong>if</strong>" verifica se a variável <strong>$nome</strong> existe e está vazia, isso significa que o usuário não digitou o nome dele. A instrução "<strong>read</strong>" faz com que o shell leia alguma informação via teclado e retorne essa informação para a variável informada.<br />
<br />
Também no script acima foi usada a palavra "<strong>else</strong>" que significa "<strong>senão</strong>". Esse bloco é executado quando o "<strong>if</strong>" retorna um valor falso.<br />
<h2>O Super IF do Shell</h2><br />
Mas o shell oferece mais opções para o "<strong>if</strong>" do que as linguagens de programação o fazem! Veja outras opções bem interessantes:<br />
<ul><br />
	<li><strong>-s </strong>: Arquivo existe, não vazio (apenas um operador)</li><br />
	<li><strong>-f </strong>: Arquivo existe, não é um diretório (apenas um operador)</li><br />
	<li><strong>-d </strong>: Diretório existe (apenas um operador)</li><br />
	<li><strong>-w </strong>: Arquivo, com permissão de escrita (apenas um operador)</li><br />
	<li><strong>-r</strong> : Arquivo, com permissão de leitura (apenas um operador)</li><br />
	<li><strong>-x </strong>: Arquivo, com parmissão de execução  -x  (apenas um operador)</li><br />
</ul><br />
Veja um exemplo:<br />
<br />
<code bash><br />
#!/bin/bash<br />
arquivo="/tmp/meuLog.txt"<br />
if [ -f "$arquivo" ]<br />
then<br />
    echo "Continuando log..." >> "$arquivo"<br />
else<br />
    echo "Criando log..." > "$arquivo"<br />
fi<br />
</code><br />
<br />
O script acima verifica se o arquivo "<strong>/tmp/meuLog.txt</strong>" existe. Caso exista ele continua o arquivo, colocando mais informações no final dele (redirecionador <strong>&gt;&gt;</strong>). Caso o arquivo não exista ele o inicia (com o redirecionador <strong>&gt;</strong>).<br />
<h2>IFs Aninhados</h2><br />
Chamamos de "<strong>ifs aninhados</strong>" as construções onde há um "<strong>if</strong>" dentro do bloco "<strong>then</strong>" ou "<strong>else</strong>" de outro "<strong>if</strong>":<br />
<br />
<code bash><br />
#!/bin/bash<br />
echo "Digite seu nome: "<br />
read nome<br />
echo "Digite sua idade: "<br />
read idade<br />
if [ -z $nome ]<br />
then<br />
    echo "Você não digitou seu nome."<br />
else<br />
    echo "Seu nome é $nome"<br />
    if [ $idade -gt 10 ]<br />
    then<br />
        echo "Você tem mais que 10 anos."<br />
    else<br />
        echo "Você tem 10 anos ou menos."<br />
    fi<br />
fi<br />
</code><br />
<br />
<h2>IF Multilevel</h2><br />
Você pode fazer comparações em sequência, com o uso do "<strong>elif</strong>", desse jeito:<br />
<br />
<code bash><br />
#!/bin/bash<br />
echo "Digite um número"<br />
read numero<br />
if [ $numero -gt 0 ];<br />
then<br />
    echo "Número positivo"<br />
elif [ $numero -lt 0 ]<br />
then<br />
    echo "Número negativo"<br />
elif [ $numero -eq 0 ]<br />
then<br />
    echo "Número é zero"<br />
else<br />
    echo "O valor fornecido não é um número!"<br />
fi<br />
</code><br />
<br />
Além do comando "<strong>if</strong>", o shell oferece opções como "<strong>case</strong>" para controle de fluxo.<br />
<h2>O Comando Case</h2><br />
O comando "<strong>case</strong>" é usado para executar um bloco de código de acordo com o valor de uma variável. O comando "<strong>case</strong>" é interessante pois pode definir diversas opções diferentes sem usar uma estrutura com diversos comandos "<strong>if</strong>", "<strong>elif</strong>" e "<strong>else</strong>". Veja um exemplo:<br />
<br />
<code bash><br />
#!/bin/bash<br />
echo -n "O que deseja fazer? (A)lmoçar/(J)antar/(S)air? [A] "<br />
read resposta<br />
case "$resposta" in<br />
    a|A|"")<br />
        echo "Então tenha um bom almoço =)"<br />
    ;;<br />
    j|J)<br />
        echo "Um jantar vai muito bem."<br />
    ;;<br />
    s|S)<br />
        echo "Saindo..."<br />
    ;;<br />
    *)<br />
        echo "Opção inválida"<br />
    ;;<br />
esac<br />
</code><br />
<br />
O script acima exibe uma mensagem e então pede uma informação do usuário. O usuário vai digitar alguma letra e então o comando "case" entra em ação. Ele verifica qual valor foi digitado pelo usuário e executa os blocos de código relativos a cada opção. Primeira opção é a padrão, por isso ela é executada mesmo que o usuário não digite um valor.Cada bloco do case é iniciado por um valor que a variável analisada pode ter, ou vários valores, separados por um pipe. Os blocos são finalizados por uma sequência de dois caracteres 'ponto-e-vírgula' (;;).<br />
<br />
<h2>Conclusão</h2><br />
<br />
A estrutura de controle "<strong>if</strong>" do shell é bem interessante pois permite fazer diversas comparações entre valores e ainda oferece opções para lidar com o sistema de arquivos. O comando "<strong>case</strong>" pode tratar diversos valores de uma vez, o que acuda a manter o código mais limpo e organizado.<br />
<br />
Até a próxima!
